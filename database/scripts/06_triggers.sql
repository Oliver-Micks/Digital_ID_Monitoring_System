-- ============================================================
-- PHASE 7: TRIGGERS & ADVANCED SECURITY
-- Connect as: digital_id_user
-- This file contains:
--  - public_holidays table
--  - dml_audit_log table
--  - functions to check holiday / restrictions
--  - DML restriction trigger & compound trigger to audit DML attempts
--  - trigger to auto-create violations when auth_status = 'NO'
--  - immutability protections (no delete in access_audit_log)
-- ============================================================

SET SERVEROUTPUT ON

-- Ensure sequences exist (idempotent)
BEGIN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE seq_audit_id START WITH 1000 INCREMENT BY 1';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

BEGIN
  EXECUTE IMMEDIATE 'CREATE SEQUENCE seq_violation_id START WITH 1 INCREMENT BY 1';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

-- Public holidays table
BEGIN
  EXECUTE IMMEDIATE '
  CREATE TABLE public_holidays (
    holiday_id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    holiday_date DATE NOT NULL UNIQUE,
    holiday_name VARCHAR2(100) NOT NULL,
    created_at DATE DEFAULT SYSDATE
  )';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

-- (Optionally insert known holidays - safe to run repeatedly)
BEGIN
  BEGIN
    INSERT INTO public_holidays (holiday_date, holiday_name) VALUES (TO_DATE('2025-12-25','YYYY-MM-DD'),'Christmas Day');
  EXCEPTION WHEN OTHERS THEN NULL;
  END;
  BEGIN
    INSERT INTO public_holidays (holiday_date, holiday_name) VALUES (TO_DATE('2025-12-26','YYYY-MM-DD'),'Boxing Day');
  EXCEPTION WHEN OTHERS THEN NULL;
  END;
  COMMIT;
END;
/

-- DML audit table (records DML attempts on key tables)
BEGIN
  EXECUTE IMMEDIATE '
  CREATE TABLE dml_audit_log (
    log_id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
    username VARCHAR2(50),
    operation VARCHAR2(20) NOT NULL,
    table_name VARCHAR2(50) NOT NULL,
    attempt_time TIMESTAMP DEFAULT SYSTIMESTAMP,
    status VARCHAR2(20) NOT NULL,
    reason VARCHAR2(200),
    day_type VARCHAR2(20)
  )';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

-- Function: is holiday
CREATE OR REPLACE FUNCTION fn_is_holiday(p_date DATE DEFAULT SYSDATE) RETURN BOOLEAN IS
  v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count FROM public_holidays WHERE TRUNC(holiday_date) = TRUNC(p_date);
  RETURN (v_count > 0);
EXCEPTION WHEN OTHERS THEN
  RETURN FALSE;
END fn_is_holiday;
/

-- Function: check DML restriction
-- Returns: 'ALLOWED' or 'BLOCKED_WEEKDAY' or 'BLOCKED_HOLIDAY'
CREATE OR REPLACE FUNCTION fn_check_dml_restriction(p_date DATE DEFAULT SYSDATE) RETURN VARCHAR2 IS
  v_day_num NUMBER;
  v_is_holiday BOOLEAN;
BEGIN
  v_day_num := TO_NUMBER(TO_CHAR(p_date, 'D')); -- depends on NLS_TERRITORY; acceptable for local tests
  v_is_holiday := fn_is_holiday(p_date);

  IF v_is_holiday THEN
    RETURN 'BLOCKED_HOLIDAY';
  END IF;

  -- In many NLS settings: Monday = 2 ... Friday = 6
  IF v_day_num BETWEEN 2 AND 6 THEN
    RETURN 'BLOCKED_WEEKDAY';
  END IF;

  RETURN 'ALLOWED';
EXCEPTION
  WHEN OTHERS THEN
    RETURN 'ERROR';
END fn_check_dml_restriction;
/

-- Compound trigger for citizens table to audit DML attempts
CREATE OR REPLACE TRIGGER trg_audit_citizen_dml
FOR INSERT OR UPDATE OR DELETE ON citizens
COMPOUND TRIGGER
  v_operation VARCHAR2(20);
  v_status VARCHAR2(20);
  v_reason VARCHAR2(200);
  v_day_type VARCHAR2(20);

  BEFORE STATEMENT IS
  BEGIN
    IF INSERTING THEN v_operation := 'INSERT';
    ELSIF UPDATING THEN v_operation := 'UPDATE';
    ELSIF DELETING THEN v_operation := 'DELETE';
    END IF;

    DECLARE
      v_check VARCHAR2(20);
    BEGIN
      v_check := fn_check_dml_restriction(SYSDATE);

      IF v_check = 'ALLOWED' THEN
        v_status := 'ALLOWED';
        v_reason := 'Weekend operation permitted';
        v_day_type := 'WEEKEND';
      ELSIF v_check = 'BLOCKED_WEEKDAY' THEN
        v_status := 'BLOCKED';
        v_reason := 'Weekday restriction';
        v_day_type := 'WEEKDAY';
      ELSIF v_check = 'BLOCKED_HOLIDAY' THEN
        v_status := 'BLOCKED';
        v_reason := 'Public holiday restriction';
        v_day_type := 'HOLIDAY';
      ELSE
        v_status := 'ERROR';
        v_reason := 'Restriction check error';
        v_day_type := 'UNKNOWN';
      END IF;
    END;
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
    NULL;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
    NULL;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
    INSERT INTO dml_audit_log (username, operation, table_name, status, reason, day_type)
    VALUES (USER, v_operation, 'CITIZENS', v_status, v_reason, v_day_type);
    COMMIT;
  END AFTER STATEMENT;
END trg_audit_citizen_dml;
/

-- Trigger: log citizen profile updates into access_audit_log
CREATE OR REPLACE TRIGGER trg_audit_citizen_updates
AFTER UPDATE OF phone, email, district ON citizens
FOR EACH ROW
DECLARE
  v_audit_id NUMBER;
  v_notes VARCHAR2(400);
BEGIN
  v_audit_id := seq_audit_id.NEXTVAL;

  v_notes := '';
  IF NVL(:OLD.phone,'NULL') != NVL(:NEW.phone,'NULL') THEN
    v_notes := v_notes || 'Phone: ' || NVL(:OLD.phone,'NULL') || ' -> ' || NVL(:NEW.phone,'NULL') || '; ';
  END IF;
  IF NVL(:OLD.email,'NULL') != NVL(:NEW.email,'NULL') THEN
    v_notes := v_notes || 'Email: ' || NVL(:OLD.email,'NULL') || ' -> ' || NVL(:NEW.email,'NULL') || '; ';
  END IF;
  IF NVL(:OLD.district,'NULL') != NVL(:NEW.district,'NULL') THEN
    v_notes := v_notes || 'District: ' || NVL(:OLD.district,'NULL') || ' -> ' || NVL(:NEW.district,'NULL') || '; ';
  END IF;

  INSERT INTO access_audit_log (
    audit_id, employee_id, citizen_id, access_time, action, data_category, auth_status, request_purpose, source_ip, notes
  ) VALUES (
    v_audit_id, 0, :OLD.citizen_id, SYSTIMESTAMP, 'CITIZEN_PROFILE_UPDATE', NULL, 'YES', NULL, NULL, v_notes
  );

  COMMIT;
END trg_audit_citizen_updates;
/

-- Trigger: auto-create privacy_violations for unauthorized access attempts
CREATE OR REPLACE TRIGGER trg_auto_create_violation
AFTER INSERT ON access_audit_log
FOR EACH ROW
WHEN (NEW.auth_status = 'NO')
DECLARE
  v_violation_id NUMBER;
BEGIN
  v_violation_id := seq_violation_id.NEXTVAL;

  INSERT INTO privacy_violations (
    violation_id, audit_id, violation_type, severity, created_at, resolved_status
  ) VALUES (
    v_violation_id,
    :NEW.audit_id,
    'UNAUTHORIZED_ACCESS_ATTEMPT',
    CASE WHEN fn_is_after_hours(:NEW.access_time) THEN 'HIGH' ELSE 'MEDIUM' END,
    SYSTIMESTAMP,
    'OPEN'
  );

  COMMIT;
END trg_auto_create_violation;
/

-- Trigger: escalate HIGH severity auto-status to INVESTIGATING
CREATE OR REPLACE TRIGGER trg_escalate_high_violations
BEFORE INSERT ON privacy_violations
FOR EACH ROW
WHEN (NEW.severity = 'HIGH')
BEGIN
  :NEW.resolved_status := 'INVESTIGATING';
END trg_escalate_high_violations;
/

-- Trigger: prevent deletion from access_audit_log (immutability)
CREATE OR REPLACE TRIGGER trg_protect_audit_log
BEFORE DELETE ON access_audit_log
FOR EACH ROW
BEGIN
  RAISE_APPLICATION_ERROR(-20003, 'Security: Audit logs are immutable and cannot be deleted.');
END trg_protect_audit_log;
/
